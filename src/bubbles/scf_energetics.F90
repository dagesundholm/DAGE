!----------------------------------------------------------------------------------!
!    Copyright (c) 2010-2018 Pauli Parkkinen, Eelis Solala, Wen-Hua Xu,            !
!                            Sergio Losilla, Elias Toivanen, Jonas Juselius        !
!                                                                                  !
!    Permission is hereby granted, free of charge, to any person obtaining a copy  !
!    of this software and associated documentation files (the "Software"), to deal !
!    in the Software without restriction, including without limitation the rights  !
!    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     !
!    copies of the Software, and to permit persons to whom the Software is         !
!    furnished to do so, subject to the following conditions:                      !
!                                                                                  !
!    The above copyright notice and this permission notice shall be included in all!
!    copies or substantial portions of the Software.                               !
!                                                                                  !
!    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    !
!    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      !
!    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   !
!    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        !
!    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, !
!    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE !
!    SOFTWARE.                                                                     !
!----------------------------------------------------------------------------------!
!----------------------------------------------------------------------------------!
!    NOTE: This file is automatically generated by the python program              !
!    'generate objects.py'. DO NOT MODIFY THIS FILE manually. To change            !
!    the contents of this file, edit the input_parameters.xml file and run         !
!    'python generate_objects.py' in the 'python/' folder.                         !
!----------------------------------------------------------------------------------!
module SCFEnergetics_class
    use globals_m
    use ISO_FORTRAN_ENV
    implicit none

    public :: SCFEnergetics

    !> The object used to store all the energetics of an electron density optimization 
    !! 
    type   :: SCFEnergetics
        !> Number of 'scf_iteration_energetics' in this object. 
        integer                   :: number_of_scf_en = 0
        !> Repulsion energy between nuclei. 
        real(REAL64)              :: nuclear_repulsion_energy = 0.0000000000d0
        !> The order numbers of iterations. 
        integer,      allocatable :: iteration_number(:)
        !> The total energy of the iterations. 
        real(REAL64), allocatable :: total_energy(:)
        !> The eigen values of orbitals in the iterations. 
        real(REAL64), allocatable :: eigen_values(:, :)
    contains
        procedure, public  :: write_scf_energetics => SCFEnergetics_write_scf_energetics
        procedure, public  :: write_energetics     => SCFEnergetics_write_energetics
        procedure, private :: write_energy_history => SCFEnergetics_write_energy_history
        procedure, public  :: destroy              => SCFEnergetics_destroy

    end type

    interface SCFEnergetics
        module procedure SCFEnergetics_init_copy
    end interface

contains

    !> Init SCFEnergetics object to 'self%scf_energetics' from input scf_energetics.
    !! The SCFEnergetics contains the history of energies. 
    function SCFEnergetics_init_copy(scf_energetics, scf_orbital_count, additional_iteration_count) &
             result(new)
        type(SCFEnergetics),  intent(in)            :: scf_energetics
        !> The number of orbitals in the new energetics. This parameter 
        !! can be used to limit the number of orbitals taken into account in the 
        !! energetics or to add additional slots for eigen values.
        integer,              intent(in)            :: scf_orbital_count
        !> Indicates how many additional iterations can be stored to the initialized
        !! object in addition to the existing ones
        integer,              intent(in)            :: additional_iteration_count
        integer                                     :: orbital_count, iteration_count
        
        type(SCFEnergetics)                         :: new

        new%nuclear_repulsion_energy = scf_energetics%nuclear_repulsion_energy
        ! get dimensions of the copied scf_energetics
        if (allocated(scf_energetics%eigen_values)) then
            orbital_count = min(size(scf_energetics%eigen_values, 1), scf_orbital_count)
            iteration_count = size(scf_energetics%eigen_values, 2)
        else
            orbital_count = 0
            iteration_count = 0
        end if
    
        ! allocate space for the histories
        allocate(new%eigen_values(scf_orbital_count, additional_iteration_count + iteration_count), &
                 source = 0.0d0)
        allocate(new%total_energy(additional_iteration_count + iteration_count), source = 0.0d0)
        
        ! copy the preexisting history to the new object
        if (allocated(scf_energetics%eigen_values)) then
            new%total_energy(:iteration_count) =  scf_energetics%total_energy
            new%eigen_values(:orbital_count, :iteration_count) = &
                scf_energetics%eigen_values(:orbital_count, :)
        end if
        
        
        
    end function
    
    !> Write the standalone SCF Energetics to file 'folder'/'base_filename'.xml.
    subroutine SCFEnergetics_write_energetics(self, folder, base_filename, iteration_count)
        class(SCFEnergetics), intent(in)         :: self
        !> Folder for the file          
        character(len=*),  intent(in)           :: folder
        !> Basename for the file
        character(len=*),  intent(in)           :: base_filename
        !> Number of iterations written to file
        integer,           intent(in), optional :: iteration_count
        
        integer                                 :: iteration_count_
        character(len=:), allocatable           :: filename

        if (present(iteration_count)) then
            iteration_count_ = iteration_count
        else
            iteration_count_ = size(self%total_energy)
        end if
        filename = trim(base_filename)//'.xml'
        
        ! open the file we are writing to 
        open(unit=WRITE_FD, file=trim(folder)//'/'//trim(filename), access='stream', form='formatted')
        
        ! write the file
        call pdebug("Dumping SCF-Energetics to `"//trim(folder)//'/'//trim(filename)//"'.", 1)
        write(WRITE_FD, '("<?xml version=""1.0""?>")')
        call self%write_scf_energetics(WRITE_FD, iteration_count_)
        
        ! close file and deallocate the filename
        close(unit=WRITE_FD)
        deallocate(filename)
    end subroutine

    !> Writes the scf_energetics 'xml'-object to the stream identified
    !! with 'file_descriptor'.
    subroutine SCFEnergetics_write_scf_energetics(self, file_descriptor, iteration_count)
        class(SCFEnergetics), intent(in)         :: self
        !> The descriptor of the file we are writing to
        integer,           intent(in)           :: file_descriptor 
        !> Number of iterations written to file
        integer,           intent(in)           :: iteration_count
        write(file_descriptor, '("<scf_energetics>")') 
        write(file_descriptor, '("    <nuclear_repulsion_energy>", f24.16, "</nuclear_repulsion_energy>")') &
            self%nuclear_repulsion_energy
        call self%write_energy_history(file_descriptor, iteration_count)
        write(file_descriptor, *)   '</scf_energetics>'
    end subroutine
        
    
    !> Writes total energy and eigen value histories as xml to the stream identified with 'file_descriptor'.
    !! The written energy history is stored in 'self%total_energy' and the 
    !! eigen value history is stored id 'self%eigen_values'. The writing of
    !! the history is cut so that only the 'iteration_count' first entries are written.
    subroutine SCFEnergetics_write_energy_history(self, file_descriptor, iteration_count)
        class(SCFEnergetics), intent(in)         :: self
        !> The descriptor of the file we are writing to
        integer,           intent(in)           :: file_descriptor 
        !> Number of iterations written to file
        integer,           intent(in)           :: iteration_count
        integer                                 :: i, j


        do i = 1, iteration_count
            write(file_descriptor, &
                '("    <scf_iteration_energetics iteration_number=""", i0, """ total_energy=""", f24.16, """ eigen_values=""")', &
                advance = 'no') &
                i, self%total_energy(i)
            do j = 1, size(self%eigen_values, 1)-1
                write(file_descriptor, '(f24.16, ", ")', advance='no') self%eigen_values(j, i)
            end do
            write(file_descriptor, '(f24.16, """ />")') &
                self%eigen_values(size(self%eigen_values, 1), i)
        end do

    end subroutine
    
    !> Destroy and deallocate the contents of the SCFEnergetic object
    subroutine SCFEnergetics_destroy(self)
        class(SCFEnergetics), intent(inout)         :: self
        if (allocated(self%total_energy)) deallocate(self%total_energy)
        if (allocated(self%eigen_values)) deallocate(self%eigen_values)
        self%nuclear_repulsion_energy = 0.0d0
    end subroutine
end module
