!----------------------------------------------------------------------------------!
!    Copyright (c) 2010-2018 Pauli Parkkinen, Eelis Solala, Wen-Hua Xu,            !
!                            Sergio Losilla, Elias Toivanen, Jonas Juselius        !
!                                                                                  !
!    Permission is hereby granted, free of charge, to any person obtaining a copy  !
!    of this software and associated documentation files (the "Software"), to deal !
!    in the Software without restriction, including without limitation the rights  !
!    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     !
!    copies of the Software, and to permit persons to whom the Software is         !
!    furnished to do so, subject to the following conditions:                      !
!                                                                                  !
!    The above copyright notice and this permission notice shall be included in all!
!    copies or substantial portions of the Software.                               !
!                                                                                  !
!    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    !
!    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      !
!    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   !
!    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        !
!    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, !
!    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE !
!    SOFTWARE.                                                                     !
!----------------------------------------------------------------------------------!
!    NOTE: This file is automatically generated by the python program              !
!    'generate_objects.py'. DO NOT MODIFY THIS FILE manually. To change            !
!    the contents of this file, edit the input_parameters.xml file and run         !
!    'python generate_objects.py' in the 'python/' folder.                         !
!----------------------------------------------------------------------------------!
module python_interface
    use Core_class
    use LCAO_m
    use ISO_FORTRAN_ENV
    implicit none
contains
    function run( &
            number_of_settings, number_of_structures, number_of_actions, number_of_basis_sets, &
            total_number_of_atoms, total_number_of_orbitals, total_number_of_shells, &
            total_number_of_subshells, total_number_of_folders, total_number_of_scf_en, &
            number_of_scf_energetics, struct_number_of_atoms, struct_number_of_orbitals, &
            struct_external_electric_field, struct_number_of_virtual_orbitals, struct_multiplicity, &
            struct_system_charge, struct_name, struct_basis_set_name, struct_basis_set_id, &
            struct_atom_type, struct_coordinates, struct_nuclear_charge, struct_number_of_basis_functions, &
            struct_ignored_basis_functions, struct_orbital_coefficients, struct_orbital_spin, &
            f3d_bubble_cell_count, f3d_bubble_lmax, f3d_bubble_cutoff_radius, f3d_cube_grid_spacing, &
            f3d_cube_cutoff_radius, f3d_bubbles_center_offset, f3d_bubbles_nlip, &
            f3d_cube_nlip, f3d_bubbles_grid_type, f3d_cube_grid_type, f3d_taylor_order, &
            quad_nlin, quad_nlog, quad_tstart, quad_tlin, quad_tlog, c3d_gbfmm, c3d_farfield_potential_input_lmax, &
            h3d_gbfmm, h3d_farfield_potential_input_lmax, h3d_farfield_potential_lmax, &
            h3d_multipole_evaluation, qd_electron_effective_mass_x, qd_electron_effective_mass_y, &
            qd_electron_effective_mass_z, qd_hole_effective_mass_x, qd_hole_effective_mass_y, &
            qd_hole_effective_mass_z, qd_electronic_constant, qd_relative_electron_diffraction_constant, &
            scf_method, scf_type, scf_update_weight, scf_restricted, hf_rohf_f, hf_rohf_a, &
            hf_rohf_b, dft_exchange_type, dft_correlation_type, dft_xc_update_method, &
            dft_xc_lmax, dft_fin_diff_order, dft_orbitals_density_evaluation, scfopt_optimizer_type, &
            scfopt_maximum_iterations, scfopt_total_energy_convergence_threshold, &
            scfopt_eigenvalue_convergence_threshold, scfopt_stored_iteration_count, &
            scfopt_initialization_iteration_count, scfopt_initialization_threshold, &
            ci_evaluate_ci, ci_singles, ci_doubles, ci_triples, ci_quadruples, act_structure_id, &
            act_scf_energetics_id, act_settings_id, act_name, act_resume, act_intermediate_orbital_store_interval, &
            act_store_result_functions, act_input_folder, act_output_folder, basis_basis_set_type, &
            basis_size, basis_number_of_shells, basis_number_of_subshells, basis_number_of_folders, &
            basis_restricted, basis_atom_type, basis_exponentials, basis_local_number_of_subshells, &
            basis_l, basis_coefficients, basis_folder_atom_type, basis_folder_path, &
            scfen_number_of_scf_en, scfen_nuclear_repulsion_energy, scfen_iteration_number, &
            scfen_total_energy, scfen_eigen_values) &
            result(success)
        !> Number of Settings Objects 
        !f2py integer,        intent(in)                                      :: number_of_settings
        integer,        intent(in)           :: number_of_settings
        !> Number of Structure Objects 
        !f2py integer,        intent(in)                                      :: number_of_structures
        integer,        intent(in)           :: number_of_structures
        !> Number of Action Objects present in input file 
        !f2py integer,        intent(in)                                      :: number_of_actions
        integer,        intent(in)           :: number_of_actions
        !> Number of Basis Set Objects 
        !f2py integer,        intent(in)                                      :: number_of_basis_sets
        integer,        intent(in)           :: number_of_basis_sets
        !f2py integer,        intent(in)                                      :: total_number_of_atoms
        integer,        intent(in)           :: total_number_of_atoms
        !f2py integer,        intent(in)                                      :: total_number_of_orbitals
        integer,        intent(in)           :: total_number_of_orbitals
        !> Number of shells (with quantum number n for atom_type) in all input basis 
        !! sets. 
        !f2py integer,        intent(in)                                      :: total_number_of_shells
        integer,        intent(in)           :: total_number_of_shells
        !> Number of subshells in all input basis sets. 
        !f2py integer,        intent(in)                                      :: total_number_of_subshells
        integer,        intent(in)           :: total_number_of_subshells
        !> Number of folders (with quantum number n for atom_type) in all input basis 
        !! sets. 
        !f2py integer,        intent(in)                                      :: total_number_of_folders
        integer,        intent(in)           :: total_number_of_folders
        !> Total number of 'scf_iteration_energetics' in the input file. 
        !f2py integer,        intent(in)                                      :: total_number_of_scf_en
        integer,        intent(in)           :: total_number_of_scf_en
        !> Total number of 'scf_energetics' objects in the input file. 
        !f2py integer,        intent(in)                                      :: number_of_scf_energetics
        integer,        intent(in)           :: number_of_scf_energetics
        !f2py integer,        intent(in), dimension(number_of_structures+1), depend(number_of_structures)           :: struct_number_of_atoms
        integer,        intent(in)           :: struct_number_of_atoms(number_of_structures+1)
        !f2py integer,        intent(in), dimension(number_of_structures+1), depend(number_of_structures), optional :: struct_number_of_orbitals
        integer,        intent(in), optional :: struct_number_of_orbitals(number_of_structures+1)
        !> homogeneous electric field 
        !f2py real(8),        intent(in), dimension(3, number_of_structures+1), depend(number_of_structures), optional :: struct_external_electric_field
        real(8),        intent(in), optional :: struct_external_electric_field(3, number_of_structures+1)
        !f2py integer,        intent(in), dimension(number_of_structures+1), depend(number_of_structures), optional :: struct_number_of_virtual_orbitals
        integer,        intent(in), optional :: struct_number_of_virtual_orbitals(number_of_structures+1)
        !> Spin multiplicity of the electronic state. 
        !f2py integer,        intent(in), dimension(number_of_structures+1), depend(number_of_structures), optional :: struct_multiplicity
        integer,        intent(in), optional :: struct_multiplicity(number_of_structures+1)
        !> sum of all nuclear and electronic charges 
        !f2py real(8),        intent(in), dimension(number_of_structures+1), depend(number_of_structures), optional :: struct_system_charge
        real(8),        intent(in), optional :: struct_system_charge(number_of_structures+1)
        !> Name or abbreviation identifying the structure. 
        !f2py character*256, intent(in), dimension(number_of_structures+1), depend(number_of_structures), optional :: struct_name
        character*256, intent(in), optional :: struct_name(number_of_structures+1)
        !> Name or abbreviation of the used basis set. 
        !f2py character*256, intent(in), dimension(number_of_structures+1), depend(number_of_structures), optional :: struct_basis_set_name
        character*256, intent(in), optional :: struct_basis_set_name(number_of_structures+1)
        !> Order number of the used basis set in input basis sets. 
        !f2py integer,        intent(in), dimension(number_of_structures+1), depend(number_of_structures), optional :: struct_basis_set_id
        integer,        intent(in), optional :: struct_basis_set_id(number_of_structures+1)
        !> Index linking the basis set with the 'atom type' of structure. By default 
        !! the 'atom_type' is the order number of atom in periodic table, but other 
        !! values can also be given. 
        !f2py integer,        intent(in), dimension(total_number_of_atoms+1), depend(total_number_of_atoms)           :: struct_atom_type
        integer,        intent(in)           :: struct_atom_type(total_number_of_atoms+1)
        !f2py real(8),        intent(in), dimension(3, total_number_of_atoms+1), depend(total_number_of_atoms)           :: struct_coordinates
        real(8),        intent(in)           :: struct_coordinates(3, total_number_of_atoms+1)
        !f2py real(8),        intent(in), dimension(total_number_of_atoms+1), depend(total_number_of_atoms)           :: struct_nuclear_charge
        real(8),        intent(in)           :: struct_nuclear_charge(total_number_of_atoms+1)
        !> The number of basis functions used for this atom. If -1 the number of available 
        !! basis functions is used. 
        !f2py integer,        intent(in), dimension(total_number_of_atoms+1), depend(total_number_of_atoms), optional :: struct_number_of_basis_functions
        integer,        intent(in), optional :: struct_number_of_basis_functions(total_number_of_atoms+1)
        !> Indeces of the ignored basis functions 
        !f2py integer,        intent(in), dimension(100, total_number_of_atoms+1), depend(total_number_of_atoms), optional :: struct_ignored_basis_functions
        integer,        intent(in), optional :: struct_ignored_basis_functions(100, total_number_of_atoms+1)
        !f2py real(8),        intent(in), dimension(10000, total_number_of_orbitals+1), depend(total_number_of_orbitals), optional :: struct_orbital_coefficients
        real(8),        intent(in), optional :: struct_orbital_coefficients(10000, total_number_of_orbitals+1)
        !f2py integer,        intent(in), dimension(total_number_of_orbitals+1), depend(total_number_of_orbitals), optional :: struct_orbital_spin
        integer,        intent(in), optional :: struct_orbital_spin(total_number_of_orbitals+1)
        !> Number of cells used in the Bubbles objects (Note: the number is scaled 
        !! with corresponding atom charge) 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: f3d_bubble_cell_count
        integer,        intent(in), optional :: f3d_bubble_cell_count(number_of_settings+1)
        !> Maximum angular momentum quantum number l used in Bubbles objects. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: f3d_bubble_lmax
        integer,        intent(in), optional :: f3d_bubble_lmax(number_of_settings+1)
        !> The radius from bubbles centers, where the Bubbles ends. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: f3d_bubble_cutoff_radius
        real(8),        intent(in), optional :: f3d_bubble_cutoff_radius(number_of_settings+1)
        !> The spacing between grid points in cube in atomic units (a0). Note: the 
        !! actual number is scaled to fit other parameter values. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: f3d_cube_grid_spacing
        real(8),        intent(in), optional :: f3d_cube_grid_spacing(number_of_settings+1)
        !> The radius from atoms centers, where the cube ends. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: f3d_cube_cutoff_radius
        real(8),        intent(in), optional :: f3d_cube_cutoff_radius(number_of_settings+1)
        !> The offset of bubbles from the center of the cube. This offset is given 
        !! as cube grid points in x, y and z directions. 
        !f2py real(8),        intent(in), dimension(3, number_of_settings+1), depend(number_of_settings), optional :: f3d_bubbles_center_offset
        real(8),        intent(in), optional :: f3d_bubbles_center_offset(3, number_of_settings+1)
        !> Number of Lagrange interpolation polynomials used in Cube grid. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: f3d_bubbles_nlip
        integer,        intent(in), optional :: f3d_bubbles_nlip(number_of_settings+1)
        !> Number of Lagrange interpolation polynomials used in Bubbles grids. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: f3d_cube_nlip
        integer,        intent(in), optional :: f3d_cube_nlip(number_of_settings+1)
        !> grid type in cells of the bubbles. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: f3d_bubbles_grid_type
        integer,        intent(in), optional :: f3d_bubbles_grid_type(number_of_settings+1)
        !> grid type in cells of the cube. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: f3d_cube_grid_type
        integer,        intent(in), optional :: f3d_cube_grid_type(number_of_settings+1)
        !> Maximum derivate order used in creating the cross terms in Function3D multiplication 
        !! 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: f3d_taylor_order
        integer,        intent(in), optional :: f3d_taylor_order(number_of_settings+1)
        !> Number of linear parameters used in gaussian quadrature. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: quad_nlin
        integer,        intent(in), optional :: quad_nlin(number_of_settings+1)
        !> Number of logarithmic parameters used in gaussian quadrature. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: quad_nlog
        integer,        intent(in), optional :: quad_nlog(number_of_settings+1)
        !> t-start value 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: quad_tstart
        real(8),        intent(in), optional :: quad_tstart(number_of_settings+1)
        !> t-lin value 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: quad_tlin
        real(8),        intent(in), optional :: quad_tlin(number_of_settings+1)
        !> t-log value 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: quad_tlog
        real(8),        intent(in), optional :: quad_tlog(number_of_settings+1)
        !> Is the used Coulomb operator based on Grid Based Fast Multipole Method 
        !! 
        !f2py logical,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: c3d_gbfmm
        logical,        intent(in), optional :: c3d_gbfmm(number_of_settings+1)
        !> Maximum angular momentum quantum number l value for the multipole evaluation. 
        !! Increasing this number will increase the accuracy of the farfield potential 
        !! evaluation. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: c3d_farfield_potential_input_lmax
        integer,        intent(in), optional :: c3d_farfield_potential_input_lmax(number_of_settings+1)
        !> Is the used Helmholtz operator based on Grid Based Fast Multipole Method 
        !! 
        !f2py logical,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: h3d_gbfmm
        logical,        intent(in), optional :: h3d_gbfmm(number_of_settings+1)
        !> Maximum angular momentum quantum number l value for the multipole evaluation. 
        !! Increasing this number will increase the accuracy of the farfield potential 
        !! evaluation. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: h3d_farfield_potential_input_lmax
        integer,        intent(in), optional :: h3d_farfield_potential_input_lmax(number_of_settings+1)
        !> Maximum angular momentum quantum number l value for the potential evaluation. 
        !! Increasing this number will increase the accuracy of the farfield potential 
        !! evaluation. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: h3d_farfield_potential_lmax
        integer,        intent(in), optional :: h3d_farfield_potential_lmax(number_of_settings+1)
        !> If the evaluation of farfield potential will be made using with no multipole 
        !! to local expansion conversions. Using this setting will increase the execution 
        !! time. Should be used only for debugging purposes. 
        !f2py logical,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: h3d_multipole_evaluation
        logical,        intent(in), optional :: h3d_multipole_evaluation(number_of_settings+1)
        !> Effective mass of electron in the x-direction. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: qd_electron_effective_mass_x
        real(8),        intent(in), optional :: qd_electron_effective_mass_x(number_of_settings+1)
        !> Effective mass of electron in the y-direction. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: qd_electron_effective_mass_y
        real(8),        intent(in), optional :: qd_electron_effective_mass_y(number_of_settings+1)
        !> Effective mass of electron in the z-direction. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: qd_electron_effective_mass_z
        real(8),        intent(in), optional :: qd_electron_effective_mass_z(number_of_settings+1)
        !> Effective mass of hole in the x-direction. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: qd_hole_effective_mass_x
        real(8),        intent(in), optional :: qd_hole_effective_mass_x(number_of_settings+1)
        !> Effective mass of hole in the y-direction. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: qd_hole_effective_mass_y
        real(8),        intent(in), optional :: qd_hole_effective_mass_y(number_of_settings+1)
        !> Effective mass of hole in the z-direction. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: qd_hole_effective_mass_z
        real(8),        intent(in), optional :: qd_hole_effective_mass_z(number_of_settings+1)
        !> Electronic constant. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: qd_electronic_constant
        real(8),        intent(in), optional :: qd_electronic_constant(number_of_settings+1)
        !> Relative electron diffraction constant. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: qd_relative_electron_diffraction_constant
        real(8),        intent(in), optional :: qd_relative_electron_diffraction_constant(number_of_settings+1)
        !> Type of the ab initio calculation 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scf_method
        integer,        intent(in), optional :: scf_method(number_of_settings+1)
        !> Determines the type of SCF loop: LCMO or Helmholtz-SCF. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scf_type
        integer,        intent(in), optional :: scf_type(number_of_settings+1)
        !> The weight with which the update is applied. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scf_update_weight
        real(8),        intent(in), optional :: scf_update_weight(number_of_settings+1)
        !> Determines if the calculation is restricted to singlet electronic configurations. 
        !! 
        !f2py logical,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scf_restricted
        logical,        intent(in), optional :: scf_restricted(number_of_settings+1)
        !> The f-parameter used for the open shells in the Restricted Open-Shell Hartree 
        !! Fock calculations. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: hf_rohf_f
        real(8),        intent(in), optional :: hf_rohf_f(number_of_settings+1)
        !> The a-parameter used for the open shells in the Restricted Open-Shell Hartree 
        !! Fock calculations. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: hf_rohf_a
        real(8),        intent(in), optional :: hf_rohf_a(number_of_settings+1)
        !> The b-parameter used for the open shells in the Restricted Open-Shell Hartree 
        !! Fock calculations. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: hf_rohf_b
        real(8),        intent(in), optional :: hf_rohf_b(number_of_settings+1)
        !> Type of the exchange functional 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: dft_exchange_type
        integer,        intent(in), optional :: dft_exchange_type(number_of_settings+1)
        !> Type of the correlation functional 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: dft_correlation_type
        integer,        intent(in), optional :: dft_correlation_type(number_of_settings+1)
        !> method to update xc object 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: dft_xc_update_method
        integer,        intent(in), optional :: dft_xc_update_method(number_of_settings+1)
        !> lmax for exc, vxc 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: dft_xc_lmax
        integer,        intent(in), optional :: dft_xc_lmax(number_of_settings+1)
        !> finite difference order for GGA evaluation, 9 is hardly any improvement 
        !! 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: dft_fin_diff_order
        integer,        intent(in), optional :: dft_fin_diff_order(number_of_settings+1)
        !> Determines if the electron density and its gradient are (re-)evaluated 
        !! from molecular orbitals. Using this setting makes the calculation more 
        !! accurate but slows it down a bit. 
        !f2py logical,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: dft_orbitals_density_evaluation
        logical,        intent(in), optional :: dft_orbitals_density_evaluation(number_of_settings+1)
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scfopt_optimizer_type
        integer,        intent(in), optional :: scfopt_optimizer_type(number_of_settings+1)
        !> The maximum number of scf-loop iterations. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scfopt_maximum_iterations
        integer,        intent(in), optional :: scfopt_maximum_iterations(number_of_settings+1)
        !> Maximum error allowed for the total energy to achieve SCF-convergence. 
        !! 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scfopt_total_energy_convergence_threshold
        real(8),        intent(in), optional :: scfopt_total_energy_convergence_threshold(number_of_settings+1)
        !> Maximum error allowed for each eigenvalue to achieve SCF-convergence. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scfopt_eigenvalue_convergence_threshold
        real(8),        intent(in), optional :: scfopt_eigenvalue_convergence_threshold(number_of_settings+1)
        !> Number of iterations stored in memory. This parameter only affects to optimizers 
        !! taking advantage of iteration history, like DIIS and KAIN. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scfopt_stored_iteration_count
        integer,        intent(in), optional :: scfopt_stored_iteration_count(number_of_settings+1)
        !> Number of iterations needed to before the optimization method of the optimizer 
        !! is used. Before this, the power method is used. 
        !f2py integer,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scfopt_initialization_iteration_count
        integer,        intent(in), optional :: scfopt_initialization_iteration_count(number_of_settings+1)
        !> Maximum error for the optimization method of the optimizer is used. If 
        !! this threshold has not been breached, the power method is used. 
        !f2py real(8),        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: scfopt_initialization_threshold
        real(8),        intent(in), optional :: scfopt_initialization_threshold(number_of_settings+1)
        !> Determines if CI-contribution to energy is evaluated. 
        !f2py logical,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: ci_evaluate_ci
        logical,        intent(in), optional :: ci_evaluate_ci(number_of_settings+1)
        !> Determines if single-excitations are included in the calculation. 
        !f2py logical,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: ci_singles
        logical,        intent(in), optional :: ci_singles(number_of_settings+1)
        !> Determines if double-excitations are included in the calculation. 
        !f2py logical,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: ci_doubles
        logical,        intent(in), optional :: ci_doubles(number_of_settings+1)
        !> Determines if triple-excitations are included in the calculation. 
        !f2py logical,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: ci_triples
        logical,        intent(in), optional :: ci_triples(number_of_settings+1)
        !> Determines if quadruple-excitations are included in the calculation. 
        !f2py logical,        intent(in), dimension(number_of_settings+1), depend(number_of_settings), optional :: ci_quadruples
        logical,        intent(in), optional :: ci_quadruples(number_of_settings+1)
        !f2py integer,        intent(in), dimension(number_of_actions+1), depend(number_of_actions)           :: act_structure_id
        integer,        intent(in)           :: act_structure_id(number_of_actions+1)
        !f2py integer,        intent(in), dimension(number_of_actions+1), depend(number_of_actions)           :: act_scf_energetics_id
        integer,        intent(in)           :: act_scf_energetics_id(number_of_actions+1)
        !f2py integer,        intent(in), dimension(number_of_actions+1), depend(number_of_actions)           :: act_settings_id
        integer,        intent(in)           :: act_settings_id(number_of_actions+1)
        !f2py integer,        intent(in), dimension(number_of_actions+1), depend(number_of_actions)           :: act_name
        integer,        intent(in)           :: act_name(number_of_actions+1)
        !> Resume to previous execution by reading in the orbitals etc. if possible 
        !! 
        !f2py logical,        intent(in), dimension(number_of_actions+1), depend(number_of_actions), optional :: act_resume
        logical,        intent(in), optional :: act_resume(number_of_actions+1)
        !> The interval of mid-storing of orbitals as number of iterations. (0: no 
        !! mid-execution storage) 
        !f2py integer,        intent(in), dimension(number_of_actions+1), depend(number_of_actions), optional :: act_intermediate_orbital_store_interval
        integer,        intent(in), optional :: act_intermediate_orbital_store_interval(number_of_actions+1)
        !> Store the result orbitals and other functions. 
        !f2py integer,        intent(in), dimension(number_of_actions+1), depend(number_of_actions), optional :: act_store_result_functions
        integer,        intent(in), optional :: act_store_result_functions(number_of_actions+1)
        !> The path to the folder where the input files (orbitals etc) are stored 
        !! to. 
        !f2py character*256, intent(in), dimension(number_of_actions+1), depend(number_of_actions), optional :: act_input_folder
        character*256, intent(in), optional :: act_input_folder(number_of_actions+1)
        !> The path to the folder where the output files are stored to. 
        !f2py character*256, intent(in), dimension(number_of_actions+1), depend(number_of_actions), optional :: act_output_folder
        character*256, intent(in), optional :: act_output_folder(number_of_actions+1)
        !f2py integer,        intent(in), dimension(number_of_basis_sets+1), depend(number_of_basis_sets)           :: basis_basis_set_type
        integer,        intent(in)           :: basis_basis_set_type(number_of_basis_sets+1)
        !> This parameter is used to determine the order number in the basis set type. 
        !! For instance if the basis set is of type GTO and this parameter is '5' 
        !! then each basis function consist of 1-5 gaussian functions. 
        !f2py integer,        intent(in), dimension(number_of_basis_sets+1), depend(number_of_basis_sets)           :: basis_size
        integer,        intent(in)           :: basis_size(number_of_basis_sets+1)
        !> Number of 'shells' in current basis set. 
        !f2py integer,        intent(in), dimension(number_of_basis_sets+1), depend(number_of_basis_sets)           :: basis_number_of_shells
        integer,        intent(in)           :: basis_number_of_shells(number_of_basis_sets+1)
        !> Number of sub shells in this basis set. This is actually the size of the 
        !! basis set in number of basis functions. 
        !f2py integer,        intent(in), dimension(number_of_basis_sets+1), depend(number_of_basis_sets), optional :: basis_number_of_subshells
        integer,        intent(in), optional :: basis_number_of_subshells(number_of_basis_sets+1)
        !> Number of atom folders in this basis set. 
        !f2py integer,        intent(in), dimension(number_of_basis_sets+1), depend(number_of_basis_sets), optional :: basis_number_of_folders
        integer,        intent(in), optional :: basis_number_of_folders(number_of_basis_sets+1)
        !> Indicates if the basis set is of restricted type. 
        !f2py logical,        intent(in), dimension(number_of_basis_sets+1), depend(number_of_basis_sets), optional :: basis_restricted
        logical,        intent(in), optional :: basis_restricted(number_of_basis_sets+1)
        !> Index linking the basis set with the 'atom type' of structure. By default 
        !! the 'atom_type' is the order number of atom in periodic table, but other 
        !! values can also be given. 
        !f2py integer,        intent(in), dimension(total_number_of_shells+1), depend(total_number_of_shells), optional :: basis_atom_type
        integer,        intent(in), optional :: basis_atom_type(total_number_of_shells+1)
        !f2py real(8),        intent(in), dimension(10, total_number_of_shells+1), depend(total_number_of_shells), optional :: basis_exponentials
        real(8),        intent(in), optional :: basis_exponentials(10, total_number_of_shells+1)
        !> Number of shells for this atom type 
        !f2py integer,        intent(in), dimension(total_number_of_shells+1), depend(total_number_of_shells), optional :: basis_local_number_of_subshells
        integer,        intent(in), optional :: basis_local_number_of_subshells(total_number_of_shells+1)
        !> Azimuthal quantum number 'l' of the subshell. 
        !f2py integer,        intent(in), dimension(total_number_of_subshells+1), depend(total_number_of_subshells), optional :: basis_l
        integer,        intent(in), optional :: basis_l(total_number_of_subshells+1)
        !f2py real(8),        intent(in), dimension(10, total_number_of_subshells+1), depend(total_number_of_subshells), optional :: basis_coefficients
        real(8),        intent(in), optional :: basis_coefficients(10, total_number_of_subshells+1)
        !> Index linking the basis set with the 'atom type' of structure. By default 
        !! the 'atom_type' is the order number of atom in periodic table, but other 
        !! values can also be given. 
        !f2py integer,        intent(in), dimension(total_number_of_folders+1), depend(total_number_of_folders), optional :: basis_folder_atom_type
        integer,        intent(in), optional :: basis_folder_atom_type(total_number_of_folders+1)
        !> Path of the folder containing the orbitals of the given atom 
        !f2py character*256, intent(in), dimension(total_number_of_folders+1), depend(total_number_of_folders), optional :: basis_folder_path
        character*256, intent(in), optional :: basis_folder_path(total_number_of_folders+1)
        !> Number of 'scf_iteration_energetics' in this object. 
        !f2py integer,        intent(in), dimension(number_of_scf_energetics+1), depend(number_of_scf_energetics), optional :: scfen_number_of_scf_en
        integer,        intent(in), optional :: scfen_number_of_scf_en(number_of_scf_energetics+1)
        !> Repulsion energy between nuclei. 
        !f2py real(8),        intent(in), dimension(number_of_scf_energetics+1), depend(number_of_scf_energetics), optional :: scfen_nuclear_repulsion_energy
        real(8),        intent(in), optional :: scfen_nuclear_repulsion_energy(number_of_scf_energetics+1)
        !> The order numbers of iterations. 
        !f2py integer,        intent(in), dimension(total_number_of_scf_en+1), depend(total_number_of_scf_en), optional :: scfen_iteration_number
        integer,        intent(in), optional :: scfen_iteration_number(total_number_of_scf_en+1)
        !> The total energy of the iterations. 
        !f2py real(8),        intent(in), dimension(total_number_of_scf_en+1), depend(total_number_of_scf_en), optional :: scfen_total_energy
        real(8),        intent(in), optional :: scfen_total_energy(total_number_of_scf_en+1)
        !> The eigen values of orbitals in the iterations. 
        !f2py real(8),        intent(in), dimension(1000, total_number_of_scf_en+1), depend(total_number_of_scf_en), optional :: scfen_eigen_values
        real(8),        intent(in), optional :: scfen_eigen_values(1000, total_number_of_scf_en+1)
        type(Core)                         :: core_object
        logical                            :: success
        integer                            :: i, icounter

        allocate(core_object%settings(number_of_settings))
        allocate(core_object%actions(number_of_actions))
        allocate(core_object%structures(number_of_structures))
        allocate(core_object%basis_sets(number_of_basis_sets))
        allocate(core_object%scf_energetics(number_of_scf_energetics))
        icounter = 1
        do i = 1, number_of_structures
            core_object%structures(i)%number_of_atoms = &
                struct_number_of_atoms(icounter)
            icounter = icounter + 1
        end do
        if (present(struct_number_of_orbitals)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%number_of_orbitals = &
                    struct_number_of_orbitals(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(struct_external_electric_field)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%external_electric_field = &
                    struct_external_electric_field(:, icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(struct_number_of_virtual_orbitals)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%number_of_virtual_orbitals = &
                    struct_number_of_virtual_orbitals(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(struct_multiplicity)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%multiplicity = &
                    struct_multiplicity(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(struct_system_charge)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%system_charge = &
                    struct_system_charge(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(struct_name)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%name = &
                    struct_name(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(struct_basis_set_name)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%basis_set_name = &
                    struct_basis_set_name(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(struct_basis_set_id)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%basis_set_id = &
                    struct_basis_set_id(icounter)
                icounter = icounter + 1
            end do
        end if
        icounter = 1
        do i = 1, number_of_structures
            core_object%structures(i)%atom_type = &
                struct_atom_type(icounter : icounter + struct_number_of_atoms(i)-1)
            icounter = icounter + struct_number_of_atoms(i)
        end do
        icounter = 1
        do i = 1, number_of_structures
            core_object%structures(i)%coordinates = &
                struct_coordinates(:, icounter : icounter + struct_number_of_atoms(i)-1)
            icounter = icounter + struct_number_of_atoms(i)
        end do
        icounter = 1
        do i = 1, number_of_structures
            core_object%structures(i)%nuclear_charge = &
                struct_nuclear_charge(icounter : icounter + struct_number_of_atoms(i)-1)
            icounter = icounter + struct_number_of_atoms(i)
        end do
        if (present(struct_number_of_basis_functions)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%number_of_basis_functions = &
                    struct_number_of_basis_functions(icounter : icounter + struct_number_of_atoms(i)-1)
                icounter = icounter + struct_number_of_atoms(i)
            end do
        end if
        if (present(struct_ignored_basis_functions)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%ignored_basis_functions = &
                    struct_ignored_basis_functions(:, icounter : icounter + struct_number_of_atoms(i)-1)
                icounter = icounter + struct_number_of_atoms(i)
            end do
        end if
        if (present(struct_orbital_coefficients)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%orbital_coefficients = &
                    struct_orbital_coefficients(:, icounter : icounter + struct_number_of_orbitals(i)-1)
                icounter = icounter + struct_number_of_orbitals(i)
            end do
        end if
        if (present(struct_orbital_spin)) then
            icounter = 1
            do i = 1, number_of_structures
                core_object%structures(i)%orbital_spin = &
                    struct_orbital_spin(icounter : icounter + struct_number_of_orbitals(i)-1)
                icounter = icounter + struct_number_of_orbitals(i)
            end do
        end if
        if (present(f3d_bubble_cell_count)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%bubble_cell_count = &
                    f3d_bubble_cell_count(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(f3d_bubble_lmax)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%bubble_lmax = &
                    f3d_bubble_lmax(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(f3d_bubble_cutoff_radius)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%bubble_cutoff_radius = &
                    f3d_bubble_cutoff_radius(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(f3d_cube_grid_spacing)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%cube_grid_spacing = &
                    f3d_cube_grid_spacing(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(f3d_cube_cutoff_radius)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%cube_cutoff_radius = &
                    f3d_cube_cutoff_radius(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(f3d_bubbles_center_offset)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%bubbles_center_offset = &
                    f3d_bubbles_center_offset(:, icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(f3d_bubbles_nlip)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%bubbles_nlip = &
                    f3d_bubbles_nlip(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(f3d_cube_nlip)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%cube_nlip = &
                    f3d_cube_nlip(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(f3d_bubbles_grid_type)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%bubbles_grid_type = &
                    f3d_bubbles_grid_type(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(f3d_cube_grid_type)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%cube_grid_type = &
                    f3d_cube_grid_type(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(f3d_taylor_order)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%function3d_settings%taylor_order = &
                    f3d_taylor_order(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(quad_nlin)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%quadrature_settings%nlin = &
                    quad_nlin(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(quad_nlog)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%quadrature_settings%nlog = &
                    quad_nlog(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(quad_tstart)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%quadrature_settings%tstart = &
                    quad_tstart(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(quad_tlin)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%quadrature_settings%tlin = &
                    quad_tlin(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(quad_tlog)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%quadrature_settings%tlog = &
                    quad_tlog(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(c3d_gbfmm)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%coulomb3d_settings%gbfmm = &
                    c3d_gbfmm(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(c3d_farfield_potential_input_lmax)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%coulomb3d_settings%farfield_potential_input_lmax = &
                    c3d_farfield_potential_input_lmax(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(h3d_gbfmm)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%helmholtz3d_settings%gbfmm = &
                    h3d_gbfmm(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(h3d_farfield_potential_input_lmax)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%helmholtz3d_settings%farfield_potential_input_lmax = &
                    h3d_farfield_potential_input_lmax(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(h3d_farfield_potential_lmax)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%helmholtz3d_settings%farfield_potential_lmax = &
                    h3d_farfield_potential_lmax(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(h3d_multipole_evaluation)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%helmholtz3d_settings%multipole_evaluation = &
                    h3d_multipole_evaluation(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(qd_electron_effective_mass_x)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%qd_settings%electron_effective_mass_x = &
                    qd_electron_effective_mass_x(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(qd_electron_effective_mass_y)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%qd_settings%electron_effective_mass_y = &
                    qd_electron_effective_mass_y(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(qd_electron_effective_mass_z)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%qd_settings%electron_effective_mass_z = &
                    qd_electron_effective_mass_z(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(qd_hole_effective_mass_x)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%qd_settings%hole_effective_mass_x = &
                    qd_hole_effective_mass_x(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(qd_hole_effective_mass_y)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%qd_settings%hole_effective_mass_y = &
                    qd_hole_effective_mass_y(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(qd_hole_effective_mass_z)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%qd_settings%hole_effective_mass_z = &
                    qd_hole_effective_mass_z(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(qd_electronic_constant)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%qd_settings%electronic_constant = &
                    qd_electronic_constant(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(qd_relative_electron_diffraction_constant)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%qd_settings%relative_electron_diffraction_constant = &
                    qd_relative_electron_diffraction_constant(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scf_method)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scf_settings%method = &
                    scf_method(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scf_type)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scf_settings%type = &
                    scf_type(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scf_update_weight)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scf_settings%update_weight = &
                    scf_update_weight(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scf_restricted)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scf_settings%restricted = &
                    scf_restricted(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(hf_rohf_f)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%hf_settings%rohf_f = &
                    hf_rohf_f(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(hf_rohf_a)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%hf_settings%rohf_a = &
                    hf_rohf_a(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(hf_rohf_b)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%hf_settings%rohf_b = &
                    hf_rohf_b(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(dft_exchange_type)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%dft_settings%exchange_type = &
                    dft_exchange_type(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(dft_correlation_type)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%dft_settings%correlation_type = &
                    dft_correlation_type(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(dft_xc_update_method)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%dft_settings%xc_update_method = &
                    dft_xc_update_method(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(dft_xc_lmax)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%dft_settings%xc_lmax = &
                    dft_xc_lmax(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(dft_fin_diff_order)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%dft_settings%fin_diff_order = &
                    dft_fin_diff_order(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(dft_orbitals_density_evaluation)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%dft_settings%orbitals_density_evaluation = &
                    dft_orbitals_density_evaluation(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scfopt_optimizer_type)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scfoptimizer_settings%optimizer_type = &
                    scfopt_optimizer_type(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scfopt_maximum_iterations)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scfoptimizer_settings%maximum_iterations = &
                    scfopt_maximum_iterations(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scfopt_total_energy_convergence_threshold)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scfoptimizer_settings%total_energy_convergence_threshold = &
                    scfopt_total_energy_convergence_threshold(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scfopt_eigenvalue_convergence_threshold)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scfoptimizer_settings%eigenvalue_convergence_threshold = &
                    scfopt_eigenvalue_convergence_threshold(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scfopt_stored_iteration_count)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scfoptimizer_settings%stored_iteration_count = &
                    scfopt_stored_iteration_count(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scfopt_initialization_iteration_count)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scfoptimizer_settings%initialization_iteration_count = &
                    scfopt_initialization_iteration_count(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scfopt_initialization_threshold)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%scfoptimizer_settings%initialization_threshold = &
                    scfopt_initialization_threshold(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(ci_evaluate_ci)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%ci_settings%evaluate_ci = &
                    ci_evaluate_ci(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(ci_singles)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%ci_settings%singles = &
                    ci_singles(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(ci_doubles)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%ci_settings%doubles = &
                    ci_doubles(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(ci_triples)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%ci_settings%triples = &
                    ci_triples(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(ci_quadruples)) then
            icounter = 1
            do i = 1, number_of_settings
                core_object%settings(i)%ci_settings%quadruples = &
                    ci_quadruples(icounter)
                icounter = icounter + 1
            end do
        end if
        icounter = 1
        do i = 1, number_of_actions
            core_object%actions(i)%structure_id = &
                act_structure_id(icounter)
            icounter = icounter + 1
        end do
        icounter = 1
        do i = 1, number_of_actions
            core_object%actions(i)%scf_energetics_id = &
                act_scf_energetics_id(icounter)
            icounter = icounter + 1
        end do
        icounter = 1
        do i = 1, number_of_actions
            core_object%actions(i)%settings_id = &
                act_settings_id(icounter)
            icounter = icounter + 1
        end do
        icounter = 1
        do i = 1, number_of_actions
            core_object%actions(i)%name = &
                act_name(icounter)
            icounter = icounter + 1
        end do
        if (present(act_resume)) then
            icounter = 1
            do i = 1, number_of_actions
                core_object%actions(i)%resume = &
                    act_resume(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(act_intermediate_orbital_store_interval)) then
            icounter = 1
            do i = 1, number_of_actions
                core_object%actions(i)%intermediate_orbital_store_interval = &
                    act_intermediate_orbital_store_interval(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(act_store_result_functions)) then
            icounter = 1
            do i = 1, number_of_actions
                core_object%actions(i)%store_result_functions = &
                    act_store_result_functions(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(act_input_folder)) then
            icounter = 1
            do i = 1, number_of_actions
                core_object%actions(i)%input_folder = &
                    act_input_folder(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(act_output_folder)) then
            icounter = 1
            do i = 1, number_of_actions
                core_object%actions(i)%output_folder = &
                    act_output_folder(icounter)
                icounter = icounter + 1
            end do
        end if
        icounter = 1
        do i = 1, number_of_basis_sets
            core_object%basis_sets(i)%basis_set_type = &
                basis_basis_set_type(icounter)
            icounter = icounter + 1
        end do
        icounter = 1
        do i = 1, number_of_basis_sets
            core_object%basis_sets(i)%size = &
                basis_size(icounter)
            icounter = icounter + 1
        end do
        icounter = 1
        do i = 1, number_of_basis_sets
            core_object%basis_sets(i)%number_of_shells = &
                basis_number_of_shells(icounter)
            icounter = icounter + 1
        end do
        if (present(basis_number_of_subshells)) then
            icounter = 1
            do i = 1, number_of_basis_sets
                core_object%basis_sets(i)%number_of_subshells = &
                    basis_number_of_subshells(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(basis_number_of_folders)) then
            icounter = 1
            do i = 1, number_of_basis_sets
                core_object%basis_sets(i)%number_of_folders = &
                    basis_number_of_folders(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(basis_restricted)) then
            icounter = 1
            do i = 1, number_of_basis_sets
                core_object%basis_sets(i)%restricted = &
                    basis_restricted(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(basis_atom_type)) then
            icounter = 1
            do i = 1, number_of_basis_sets
                core_object%basis_sets(i)%atom_type = &
                    basis_atom_type(icounter : icounter + basis_number_of_shells(i)-1)
                icounter = icounter + basis_number_of_shells(i)
            end do
        end if
        if (present(basis_exponentials)) then
            icounter = 1
            do i = 1, number_of_basis_sets
                core_object%basis_sets(i)%exponentials = &
                    basis_exponentials(:, icounter : icounter + basis_number_of_shells(i)-1)
                icounter = icounter + basis_number_of_shells(i)
            end do
        end if
        if (present(basis_local_number_of_subshells)) then
            icounter = 1
            do i = 1, number_of_basis_sets
                core_object%basis_sets(i)%local_number_of_subshells = &
                    basis_local_number_of_subshells(icounter : icounter + basis_number_of_shells(i)-1)
                icounter = icounter + basis_number_of_shells(i)
            end do
        end if
        if (present(basis_l)) then
            icounter = 1
            do i = 1, number_of_basis_sets
                core_object%basis_sets(i)%l = &
                    basis_l(icounter : icounter + basis_number_of_subshells(i)-1)
                icounter = icounter + basis_number_of_subshells(i)
            end do
        end if
        if (present(basis_coefficients)) then
            icounter = 1
            do i = 1, number_of_basis_sets
                core_object%basis_sets(i)%coefficients = &
                    basis_coefficients(:, icounter : icounter + basis_number_of_subshells(i)-1)
                icounter = icounter + basis_number_of_subshells(i)
            end do
        end if
        if (present(basis_folder_atom_type)) then
            icounter = 1
            do i = 1, number_of_basis_sets
                core_object%basis_sets(i)%folder_atom_type = &
                    basis_folder_atom_type(icounter : icounter + basis_number_of_folders(i)-1)
                icounter = icounter + basis_number_of_folders(i)
            end do
        end if
        if (present(basis_folder_path)) then
            icounter = 1
            do i = 1, number_of_basis_sets
                core_object%basis_sets(i)%folder_path = &
                    basis_folder_path(icounter : icounter + basis_number_of_folders(i)-1)
                icounter = icounter + basis_number_of_folders(i)
            end do
        end if
        if (present(scfen_number_of_scf_en)) then
            icounter = 1
            do i = 1, number_of_scf_energetics
                core_object%scf_energetics(i)%number_of_scf_en = &
                    scfen_number_of_scf_en(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scfen_nuclear_repulsion_energy)) then
            icounter = 1
            do i = 1, number_of_scf_energetics
                core_object%scf_energetics(i)%nuclear_repulsion_energy = &
                    scfen_nuclear_repulsion_energy(icounter)
                icounter = icounter + 1
            end do
        end if
        if (present(scfen_iteration_number)) then
            icounter = 1
            do i = 1, number_of_scf_energetics
                core_object%scf_energetics(i)%iteration_number = &
                    scfen_iteration_number(icounter : icounter + scfen_number_of_scf_en(i)-1)
                icounter = icounter + scfen_number_of_scf_en(i)
            end do
        end if
        if (present(scfen_total_energy)) then
            icounter = 1
            do i = 1, number_of_scf_energetics
                core_object%scf_energetics(i)%total_energy = &
                    scfen_total_energy(icounter : icounter + scfen_number_of_scf_en(i)-1)
                icounter = icounter + scfen_number_of_scf_en(i)
            end do
        end if
        if (present(scfen_eigen_values)) then
            icounter = 1
            do i = 1, number_of_scf_energetics
                core_object%scf_energetics(i)%eigen_values = &
                    scfen_eigen_values(:, icounter : icounter + scfen_number_of_scf_en(i)-1)
                icounter = icounter + scfen_number_of_scf_en(i)
            end do
        end if
        success = core_object%run()
    end function
end module
